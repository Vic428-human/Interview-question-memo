
下一個挑戰：202. 快樂數

快樂數的定義是：對於一個正整數,
每一次都將其替換為它每個數位平方和。
然後重複這個過程，直到這個數變為 1

訓練你如何判斷一個過程是否會陷入無限循環。在博弈中，
理解牌局或遊戲狀態是否會回到之前的狀態，
或者是否會趨於某種穩定結果，是非常重要的。

### 是否會回到之前的狀態?
根據數論，十進位的快樂數只有一個無窮循環如下：
4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 

循環檢測 (Cycle Detection)，
你需要找出一個方法來判斷這個「數位平方和」
的過程是否會陷入無限循環。
這可以用 快慢指針法 (Floyd's Cycle-Finding Algorithm)，
也就是龜兔賽跑演算法來解決，
這個演算法在很多判斷循環的問題中都非常有用。

初始化set

```
const seen = new Set();
// 初始 seen: Set(0) {}
```

快樂數的前提，只要是1就是快樂數，如果不是1就不是
如果數字沒出現過，代表還沒被計算，，那就繼續執行回迴圈，直到這個數字之前出現過，又再次出現，才停止迴圈。

快樂數，就是把每個數字都平方後在相加，第一個直覺想到的會是讓數字先變成字串，變成字串後，透過split，獲得陣列，有了陣列就能map，讓每個字串先轉換成數字後再平方，透過reduce方式加總，得出一個新的數字。

如果當前數字是1，就是快樂數，如果不是且出現過的數字中沒有新的數字，代表還沒產生一個完整的循環，那我們就要繼續按照相同的相加規則繼續往下加直到數字也出現過，或是數字為1才跳出迴圈。
```
#### 方法一：使用 Set 檢測循環
```javascript
function isHappy(n) {
    const seen = new Set(); // 用來記錄已經出現過的數字，避免無限循環
    
    while (n !== 1 && !seen.has(n)) {
        seen.add(n);
        n = String(n).split('') // 將數字轉為字串並分割成陣列
                   .map(d => parseInt(d) ** 2) // 計算每個位數的平方
                   .reduce((sum, num) => sum + num, 0); // 計算平方和
    }
    
    return n === 1; // 如果最終 n 是 1，就是快樂數
}

// 測試
console.log(isHappy(19)); // true
console.log(isHappy(4));  // false
```

什麼是 \log_{10}N？
\log_{10}N 讀作「以 10 為底，N 的對數」或者「\text{log} 以 10 為底的 N」。
它的基本意思是：
10 要自乘多少次，才會等於 N？
這個「多少次」就是 \log_{10}N 的值。
簡單的例子：
 * \log_{10}100 等於多少？
   * 問：10 要自乘多少次才會等於 100？
   * 答：10 \times 10 = 100，也就是 10 自乘了 2 次。
   * 所以，\log_{10}100 = 2。
 * \log_{10}1000 等於多少？
   * 問：10 要自乘多少次才會等於 1000？
   * 答：10 \times 10 \times 10 = 1000，也就是 10 自乘了 3 次。
   * 所以，\log_{10}1000 = 3。
 * \log_{10}10 等於多少？
   * 問：10 要自乘多少次才會等於 10？
   * 答：10 自乘了 1 次。
   * 所以，\log_{10}10 = 1。
 * \log_{10}1 等於多少？
   * 問：10 要自乘多少次才會等於 1？
   * 答：任何數字的 0 次方都等於 1 (除了 0 的 0 次方這個特例)。
   * 所以，\log_{10}1 = 0。
與數字位數的關係：
在電腦科學或演算法分析中，我們經常使用 \log_{10}N 來表示一個數字 N 的位數。
 * N=1 到 9 (一位數): \log_{10}N 的值在 0 到 1 之間。
 * N=10 到 99 (兩位數): \log_{10}N 的值在 1 到 2 之間。
 * N=100 到 999 (三位數): \log_{10}N 的值在 2 到 3 之間。
你會發現，一個正整數 N 的位數 D 其實就是 \lfloor\log_{10}N\rfloor + 1 (讀作「\log_{10}N 向下取整再加一」)。
例如：
 * N = 19，\log_{10}19 \approx 1.27， \lfloor1.27\rfloor + 1 = 1 + 1 = 2 (兩位數)。
 * N = 82，\log_{10}82 \approx 1.91， \lfloor1.91\rfloor + 1 = 1 + 1 = 2 (兩位數)。
 * N = 100，\log_{10}100 = 2， \lfloor2\rfloor + 1 = 2 + 1 = 3 (三位數)。
在分析時間複雜度時，因為我們只關心數量級或成長趨勢，所以常數和一些細節會被忽略。因此，當我們說某個操作的時間複雜度是 O(D)（D 是位數），而 D 又大致等於 \log_{10}N 時，我們就會簡化為 O(\log N)。
總之，\log_{10}N 就是在問 10 要乘幾次才會變成 N。它在描述「數字的位數」或「隨著數字增大，但增長速度相對緩慢」時非常有用。
