
下一個挑戰：202. 快樂數

快樂數的定義是：對於一個正整數,
每一次都將其替換為它每個數位平方和。
然後重複這個過程，直到這個數變為 1

訓練你如何判斷一個過程是否會陷入無限循環。在博弈中，
理解牌局或遊戲狀態是否會回到之前的狀態，
或者是否會趨於某種穩定結果，是非常重要的。

### 是否會回到之前的狀態?
根據數論，十進位的快樂數只有一個無窮循環如下：
4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 

循環檢測 (Cycle Detection)，
你需要找出一個方法來判斷這個「數位平方和」
的過程是否會陷入無限循環。
這可以用 快慢指針法 (Floyd's Cycle-Finding Algorithm)，
也就是龜兔賽跑演算法來解決，
這個演算法在很多判斷循環的問題中都非常有用。

初始化set

```
const seen = new Set();
// 初始 seen: Set(0) {}
```

快樂數的前提，只要是1就是快樂數，如果不是1就不是
如果數字沒出現過，代表還沒被計算，，那就繼續執行回迴圈，直到這個數字之前出現過，又再次出現，才停止迴圈。

快樂數，就是把每個數字都平方後在相加，第一個直覺想到的會是讓數字先變成字串，變成字串後，透過split，獲得陣列，有了陣列就能map，讓每個字串先轉換成數字後再平方，透過reduce方式加總，得出一個新的數字。

如果當前數字是1，就是快樂數，如果不是且出現過的數字中沒有新的數字，代表還沒產生一個完整的循環，那我們就要繼續按照相同的相加規則繼續往下加直到數字也出現過，或是數字為1才跳出迴圈。
```
#### 方法一：使用 Set 檢測循環
```javascript
function isHappy(n) {
    const seen = new Set(); // 用來記錄已經出現過的數字，避免無限循環
    
    while (n !== 1 && !seen.has(n)) {
        seen.add(n);
        n = String(n).split('') // 將數字轉為字串並分割成陣列
                   .map(d => parseInt(d) ** 2) // 計算每個位數的平方
                   .reduce((sum, num) => sum + num, 0); // 計算平方和
    }
    
    return n === 1; // 如果最終 n 是 1，就是快樂數
}

// 測試
console.log(isHappy(19)); // true
console.log(isHappy(4));  // false
```
