


什麼是時間複雜度 (Time Complexity)？
在 LeetCode (以及演算法領域) 中，時間複雜度是用來衡量一個演算法執行所需時間的成長趨勢。它並不是指演算法實際執行了多少秒，而是指隨著輸入資料量的增加，演算法執行時間會如何變化。這是一個非常重要的概念，因為它可以幫助你判斷一個演算法是否高效，尤其是在處理大量資料時。
想像一下，你有兩個解決相同問題的方法：
 * 一個方法在處理 100 筆資料時需要 1 毫秒，處理 1000 筆資料時需要 10 毫秒，處理 10000 筆資料時需要 100 毫秒。
 * 另一個方法在處理 100 筆資料時需要 1 毫秒，處理 1000 筆資料時需要 100 毫秒，處理 10000 筆資料時需要 10000 毫秒。
很明顯，第一個方法更有效率，因為它的執行時間隨著資料量的增加而線性成長，而第二個方法則是非線性成長。時間複雜度就是用來形式化描述這種成長趨勢的工具。
如何表示時間複雜度？
我們通常使用大 O 符號 (Big O Notation) 來表示時間複雜度。大 O 符號提供了一個演算法執行時間的上限 (upper bound)。它會忽略常數因子和低階項，只關注對執行時間影響最大的部分。
以下是一些常見的時間複雜度等級，從最快到最慢排列：
 * O(1) - 常數時間 (Constant Time)
   * 無論輸入資料量多大，執行時間都是固定的。
   * 範例：存取陣列中的一個元素、哈希表查找 (平均情況)。
 * O(log n) - 對數時間 (Logarithmic Time)
   * 執行時間隨著輸入資料量的增加而非常緩慢地增加。通常發生在每次操作都能將問題規模減半的情況。
   * 範例：二分搜尋 (Binary Search)。
 * O(n) - 線性時間 (Linear Time)
   * 執行時間與輸入資料量成正比。
   * 範例：遍歷一個陣列、尋找陣列中的最大值。
 * O(n log n) - 線性對數時間 (Linear-Logarithmic Time)
   * 比線性時間慢，但比平方時間快。
   * 範例：常見的排序演算法，如快速排序 (Quick Sort)、合併排序 (Merge Sort)。
 * O(n^2) - 平方時間 (Quadratic Time)
   * 執行時間與輸入資料量的平方成正比。通常發生在有嵌套迴圈且每個迴圈都遍歷所有輸入的情況。

### 常數因子 跟 低階項說明
* 常數因子：一個操作可能需要 5 個時鐘週期，另一個需要 10 個時鐘週期。但當 n 變得巨大時，這 5 倍或 10 倍的差異相對於 n 的指數成長來說微不足道。我們更關心的是它是「線性增長」還是「平方增長」，而不是具體快了幾倍。
 * 低階項：一個演算法的執行時間可能是 n^2 + 2n + 5。當 n 變得非常大時，n^2 會比 2n 和 5 增長得快得多。舉例來說，當 n = 1000 時，n^2 = 1,000,000，而 2n = 2000， 5 仍然是 5。明顯，n^2 項是主導，決定了整體成長趨勢。低階項的影響會變得可以忽略不計。
